#!/usr/bin/env python

import contextlib
import errno
import getpass
import optparse
import os
import subprocess
import sys
import tempfile

import GnuPGInterface

version = '0.1'

def print_help():
    print '''\
Usage: sala [options] action file(s)...

Store passwords and other sensitive information to plain text files.
The information is protected by GPG's symmetrical encryption.

Action can be "get" for reading entries or "set" for modifying or
creating entries. Files and directories are created if they don't
already exist.

Options:
  -v, --version  Show version number and exit
  -h, --help     Show this help'''
    sys.exit(2)


def print_version():
    print 'sala version %s' % version
    print '''
Copyright (C) 2011 Petri Lehtinen <petri@digip.org>

sala is free software; you can redistribute it and/or modify it under
the terms of the MIT license. See the file LICENSE distributed with
the source code for details, or visit http://www.digip.org/sala/.'''
    sys.exit(0)


def ensure_files_exist(files):
    absent = []
    for filename in files:
        if not os.access(filename, os.R_OK):
            absent.append(filename)

    if len(absent) == 1:
        print >>sys.stderr, 'Error: File does not exist:', absent[0]
        sys.exit(1)

    elif absent:
        print >>sys.stderr, 'Error: The following files do not exist:', \
            ', '.join(absent)
        sys.exit(1)


def read_passphrase(prompt, confirm=False, options=None):
    passphrase = getpass.getpass(prompt + ': ')
    if not passphrase:
        print >>sys.stderr, 'Empty passphrase is not allowed'
        return False

    if options and passphrase in [str(x) for x in options]:
        return passphrase

    if confirm:
        other = getpass.getpass('Confirm: ')
        if other != passphrase:
            print >>sys.stderr, 'Passphrases did not match'
            return False

    return passphrase


def make_parent_dirs(filename):
    try:
        os.makedirs(os.path.dirname(filename))
    except OSError, exc:
        if exc.errno != errno.EEXIST:
            raise


def generate_passphrases():
    p = subprocess.Popen(
        'pwgen -1 8 10', shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

    data = p.communicate()[0]

    if p.returncode != 0:
        return []
    else:
        return data.split()


def gpg_encrypt(filename, passphrase, content):
    logger = tempfile.TemporaryFile()
    stderr = tempfile.TemporaryFile()
    target = open(filename + '.tmp', 'w')

    with contextlib.nested(logger, stderr, target):
        gnupg = GnuPGInterface.GnuPG()
        gnupg.options.armor = 1
        gnupg.options.meta_interactive = 0

        p = gnupg.run(
            ['--symmetric'],
            create_fhs=['stdin', 'passphrase'],
            attach_fhs={
                'stdout': target,
                'stderr': stderr,
                'logger': logger,
            })

        p.handles['passphrase'].write(passphrase)
        p.handles['passphrase'].close()

        p.handles['stdin'].write(content)
        p.handles['stdin'].close()

    try:
        p.wait()
    except IOError, exc:
        print >>sys.stderr, exc
        os.remove(filename + '.tmp')
    else:
        os.rename(filename + '.tmp', filename)


def gpg_decrypt(filename, passphrase):
    logger = tempfile.TemporaryFile()
    stderr = tempfile.TemporaryFile()
    source = open(filename)

    with contextlib.nested(logger, stderr, source):
        gnupg = GnuPGInterface.GnuPG()
        gnupg.options.armor = 1
        gnupg.options.meta_interactive = 0

        p = gnupg.run(
            ['--decrypt'],
            create_fhs=['stdout', 'passphrase'],
            attach_fhs={
                'stdin': source,
                'stderr': stderr,
                'logger': logger,
            })

        p.handles['passphrase'].write(passphrase)
        p.handles['passphrase'].close()

        content = p.handles['stdout'].read()
        p.handles['stdout'].close()

    try:
        p.wait()
    except IOError:
        return ''
    else:
        return content

def main():
    parser = optparse.OptionParser(
        usage='%prog action [file...]',
        add_help_option=False
        )
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('-v', '--version', action='store_true')

    options, args = parser.parse_args()

    if options.version:
        print_version()

    if options.help or not args or len(args) < 2:
        print_help()

    action = args[0]
    files = args[1:]

    if action not in ['get', 'set']:
        print_help()

    if action == 'get':
        ensure_files_exist(files)

    passphrase = read_passphrase('Enter the master passphrase')
    if not passphrase:
        sys.exit(1)

    print ''

    if action == 'get':
        for filename in files:
            secret = gpg_decrypt(filename, passphrase)
            if secret:
                print '%s: %s' % (filename, secret)
            else:
                print 'Error: Failed to decrypt %s' % filename
            print ''

    elif action == 'set':
        for filename in files:
            pwlist = generate_passphrases()
            if pwlist:
                options = range(len(pwlist))
                prompt = 'Select a number from the list ' + \
                    'or type a new secret for ' + filename

                for i, pw in enumerate(pwlist):
                    print '%d. %s' % (i, pw)

                print ''
            else:
                options = None
                prompt = 'Type a new secret for ' + filename

            secret = read_passphrase(prompt, confirm=True, options=options)
            if secret is False:
                continue

            if options:
                try:
                    i = int(secret)
                    secret = pwlist[i]
                except (ValueError, KeyError):
                    pass

            make_parent_dirs(filename)
            gpg_encrypt(filename, passphrase, secret)

if __name__ == '__main__':
    sys.exit(main() or 0)
